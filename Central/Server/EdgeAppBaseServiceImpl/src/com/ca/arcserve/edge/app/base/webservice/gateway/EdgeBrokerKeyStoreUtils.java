package com.ca.arcserve.edge.app.base.webservice.gateway;

import java.io.File;
import java.io.FileInputStream;
import java.io.FileOutputStream;
import java.io.IOException;
import java.net.InetAddress;
import java.net.UnknownHostException;
import java.security.KeyStore;
import java.security.KeyStoreException;
import java.security.NoSuchAlgorithmException;
import java.security.cert.Certificate;
import java.security.cert.CertificateException;
import java.security.cert.X509Certificate;
import java.util.ArrayList;
import java.util.Iterator;
import java.util.List;

import org.apache.log4j.Logger;

import com.arcserve.edge.util.WindowsRegistryUtils;
import com.ca.arcserve.edge.app.base.util.CommonUtil;
import com.ca.arcserve.edge.app.base.util.WindowsRegistry;
import com.ca.arcserve.edge.app.base.webservice.contract.common.StringUtil;

public class EdgeBrokerKeyStoreUtils {

	private static Logger logger = Logger.getLogger( EdgeBrokerKeyStoreUtils.class );
	private static String KEY_TOOL_PATH = makeFilePath(WindowsRegistryUtils.getUDPInstallationPath(), "TOMCAT\\JRE\\bin\\keytool.exe");
	private static String BROKER_PATH = makeFilePath(WindowsRegistryUtils.getUDPInstallationPath(), "Configuration\\Certificate");
	private static String BROKER_KS_PATH = makeFilePath(WindowsRegistryUtils.getUDPInstallationPath(), "Configuration\\Certificate\\broker.ks");;
	private static String storePass = "Arcserve123456";
	private static final String BROKER_ALIAS="broker"; 
	
	public static String getBrokerProtocol(){
		String brokerProtocol = CommonUtil.getApplicationExtentionKey(WindowsRegistry.VALUE_BROKER_PROTOCOL);
		String webServer_URL = CommonUtil.getApplicationExtentionKey(WindowsRegistry.KEY_NAME_ROOT_WEBSERVER, WindowsRegistry.VALUE_NAME_WEBSERVER_URL);
		if(webServer_URL == null || webServer_URL.indexOf(":") < 0){
			CommonUtil.setApplicationExtentionKey(WindowsRegistry.VALUE_BROKER_PROTOCOL, "tcp");
			return "tcp";
		}
		String consoleProtocol = webServer_URL.substring(0, webServer_URL.indexOf(":"));
		if(consoleProtocol.equalsIgnoreCase("http") || consoleProtocol.equalsIgnoreCase("https")){
			if(StringUtil.isEmptyOrNull(brokerProtocol) || !brokerProtocol.equalsIgnoreCase("tcp")){
				CommonUtil.setApplicationExtentionKey(WindowsRegistry.VALUE_BROKER_PROTOCOL, consoleProtocol);
				return consoleProtocol;
			}
		}
		return "tcp";
	}
	
	public static int getBrokerPort(){
		String messageServicePort = CommonUtil.getApplicationExtentionKey(WindowsRegistry.KEY_NAME_ROOT_MESSAGESERVICE, WindowsRegistry.VALUE_MESSAGESERVICE_PORT);
		if(StringUtil.isEmptyOrNull(messageServicePort)){
			return 8030;
		}else
			return Integer.valueOf(messageServicePort);
	}
	
	public String getBrokerKSPassWord(){
		return storePass;
	}
	
	public String getBrokerKSPath(){
		return BROKER_KS_PATH;
	}
	
	private static String makeFilePath( String folderPath, String fileName )
	{
		if (!folderPath.endsWith( "\\" ))
			folderPath += "\\";
		return folderPath + fileName;
	}

	public int doBrokerCertificate(){
        int nResult = -1;
		do
		{		
			// 1. create keystore
			logger.info("Start create break keystore");
			createBreakServerKeystore();
			if (!isValidFile(BROKER_KS_PATH))
			{
				logger.error(String.format("Failed to create keystore. keystoreFile = %s", BROKER_KS_PATH));
				nResult = -2;
				break;
			}
			nResult = 0;
		}while(false);
		return nResult;
	}
	
	private void createBreakServerKeystore() {
		String hostname = "";
		List<String> dnsNames = new ArrayList<String>();
		getDnsNameList(dnsNames);
		try {
			hostname = InetAddress.getLocalHost().getHostName().toLowerCase();
		} catch (UnknownHostException e) {
			logger.error(e.getMessage(), e);
			return;
		}
		File file = new File(BROKER_KS_PATH);
		if (file.exists()) {
			logger.info("break keystore is exist!");
				boolean tocreate=false;
				try {
					tocreate = this.removeSHA1DASCertIfDetected(BROKER_ALIAS);
				} catch (KeyStoreException e) {
					logger.error(e.getMessage(), e);
					return;
				}catch (IOException e) {
					logger.error(e.getMessage(), e);
					return;
				}
				if(tocreate){
					logger.error("The self-signed certificate generated by SHA1 has been removed.");
					return;
				}else {
					logger.error("Certificate already exists, skip generating self-signed certificate.");
					return;
				}
		}
		StringBuilder sanNames = new StringBuilder(); 
		Iterator<String> itr = dnsNames.iterator();
		sanNames.append("san=");
		while(itr.hasNext()){
			sanNames.append("dns:" + itr.next());
			if(itr.hasNext()) {
				sanNames.append(",");
			}
		}
		validateBrokerDir();
		createBrokerKeyStore("CN=" + hostname, sanNames.toString());
	}
	
	private void validateBrokerDir(){
		File file =new File(BROKER_PATH);    
		if  (!file .exists()  && !file .isDirectory())       
			file .mkdir();    
	}
	
	private void getDnsNameList(List<String> dnsNameList){
		if(dnsNameList == null){
			dnsNameList = new ArrayList<String>();
		}
		dnsNameList.add("localhost");	// add localhost as the first one.
	}
	
	private boolean removeSHA1DASCertIfDetected(String alias) throws KeyStoreException,IOException{
		boolean tocreate=false;
		
		KeyStore keystore=null;
		
		try {
			keystore = KeyStore.getInstance(KeyStore.getDefaultType());
			keystore.load(new FileInputStream(BROKER_KS_PATH), storePass.toCharArray());
		} catch (KeyStoreException e) {
			logger.error("Can not get the KeyStore Instance!");
			logger.error(e.getMessage(), e);
			System.exit(-1);
		}catch (NoSuchAlgorithmException e) {
			logger.error("Can not find algorithm to check the integrity of the keystore!");
			logger.error(e.getMessage(), e);
			System.exit(-1);
		} catch (CertificateException e) {
			logger.error("Some of the certificates in keystore can not be loaded!");
			logger.error(e.getMessage(), e);
			System.exit(-1);
		} catch (IOException |NullPointerException e) {
			logger.error("Fail to load the keystore file!");
			logger.error(e.getMessage(), e);
			System.exit(-1);
		}
		
		File file = new File(BROKER_KS_PATH);
		
			Certificate cert = keystore.getCertificate(alias);
			if(cert==null){
				logger.error("No Tomcat Server Certificate was found, a new self-signed certificate with SHA256 will be generated.");
		        tocreate=true;
		    }else if (cert.getType().equals("X.509")) {
		        	X509Certificate certif = (X509Certificate) cert;
		            String sigalgname=	certif.getSigAlgName();
		            logger.info("A cert whose SIGALG is "+sigalgname+" is found.");
		            
		            switch (sigalgname) {
		                case "SHA1withDSA": {
		                    	
		                        keystore.deleteEntry(alias);
		                        
		                        try {
									keystore.store(new FileOutputStream(BROKER_KS_PATH), storePass.toCharArray());
									tocreate = true;
								} catch (NoSuchAlgorithmException e) {
									logger.error("Can not find the appropriate data integrity algorithm!");
									logger.error(e.getMessage(), e);
									System.exit(-1);
								} catch (CertificateException e) {
									logger.error("Some of the certificates included in the keystore data could not be stored!");
									logger.error(e.getMessage(), e);
									System.exit(-1);
								} catch (IOException e) {
									logger.error("Fail to store to the keystore file!");
									logger.error(e.getMessage(), e);
									if(!file.canWrite()){
										throw e;
									}else 
										System.exit(-1);
								}
		                        break;
		               }
		                case "SHA256withRSA": {
		                    	tocreate = false;
		                        break;
		                }
		                default: {
		                    	tocreate = false;
		                        break;
		                }
		              }
		            } else{
		            	String certype=cert.getType();
		            	logger.info("A cert whose type is "+certype+" is found.");
			            tocreate=false;
		            }	
		 return tocreate;
		
	}
	
	private boolean isValidFile(String strFile)
	{
		boolean result = false;
		
		File file = new File(strFile);
		
		if (file.exists())
		{
			result = true;
		}
		
		return result;
	}
	
	private int executeCommand(String[] commands)
	{
		for (int i = 0; i < commands.length; i++) {
			logger.debug(String.format("command = %s", commands[i]));
		}
		int nResult = 0;		
		try
		{
			Process process = Runtime.getRuntime().exec(commands);
			process.waitFor();
			nResult = process.exitValue();
		}
		catch (Exception e)
		{
			logger.error(e.getMessage() + e.getStackTrace());
			nResult = -1;
		}

		logger.debug(String.format("nResult = %d", nResult));
		
		return nResult;
	}
	
	private int createBrokerKeyStore(String dName, String dns){
		String[] arstringCommand = new String[] {
				KEY_TOOL_PATH,
				"-genkeypair", 
				"-alias", 
				BROKER_ALIAS,
				"-dname",
				dName,
				"-ext",
				dns,
				"-keyalg",
				"RSA",
				"-keystore", 
				BROKER_KS_PATH,
				"-keypass",
				storePass,
				"-storepass",
				storePass,
				"-validity",
				"18250"
		};
		return executeCommand(arstringCommand);	
	}
}
